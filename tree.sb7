sb7 command add TREE 700 -none ; # Conflicts with BOTTREE: don't use that command word!

proc @tree { nick host handle chan arg } {
	FLAGS

	switch -exact -- [string tolower $1] {

		help {
			print -help $nick "\[TREE\]:"
			print -help $nick "Syntax: $::botnick TREE HELP"
			print -help $nick "Syntax: $::botnick TREE CREDITS"
			print -help $nick "Syntax: $::botnick TREE"
			print -help $nick "TREE draws out the current botmap based on ${::botnick}'s point of view."
			return 0
		}

		cr - cred - credit - credits { print -help -return $nick "Original code provided by Eggdrop core coder thommey on 2010-10-20. Code was released to the public domain by the coder, but permission was explicitly requested (and granted) for use of this code, modified, in StormBot.TCL (see code for his release statement). Our appreciation to him for his contribution." }

		default {
			if [isempty 1] {
				set me ${::botnet-nick}
			} {
				if ![islinked [join $1]] {print -help $nick "\[TREE\] [join $1] isn't linked into the botnet." ; return }
				set me [casebot [join $1]]
			}

			# Get tree
			set tree [tree $me]

			# Print tree
			foreach a $tree { print $nick $a }

			# Calculate hops (there's a slight variation to eggdrop's count by ~0.5: I'm not going to sweat it).
			one hops
			set ll [expr [llength [bots]] + 1]
			foreach a [bots] {
				#incr hops [tree:hops_scan $a]
				set trace [tree:path $me $a]
				set h [expr [llength $trace] - 1]
				incr hops $h
			}
			print $nick "Average hops: [format %.1f [ expr ${hops}.0 / $ll ]], total bots: $ll"
			return 0
		}
	}
	?
}

#############################################################################

# [TREE code copyright notice]

# [16Sep12 15:47:15-0700] <thommey> sure, I hereby grant you the irrevokable permission to use, modify, redistribute, relicense, re-assign copyright (not really legal in the US) and/or delete and/or do whatever you want with the code
# [16Sep12 15:50:06-0700] <thommey> I dedicate any and all copyright interest in this code to the public domain. I make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. I intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this code under copyright law. 

# http://paste.tclhelp.net/?id=bnc

# Returns the bottree as a list of lines, the optional "root" arguments is the botnick of the bot you want on top. The other arguments are internal use only.
# defaults to $::botnet-nick
# Internal arguments:
# childrenarraystr is a one-time generated array representation of the direct children of bots, generated by [getallbotschildren] on the first call
# indentionlvl keep track of the current depth in the tree, it determines the "  " indention of the tree elements (and is used to detect the first call)
# endlvls keeps track of the indention levels that have already ended to determine whether to continue drawing "| | |" or not
# callsource prevents recursing into the direction we came from (botA -> botB -/-> botA)

# To "dummy" a tree with pre-set data (such as: a server map), set-up the
# variable $CHILDRENARRAYSTR (knowing it will be used by ARRAY SET) as a LIST:
# BOT {hub leaf leaf leaf ...} BOT {hub leaf leaf leaf ...} ...

proc tree { { root "" } { childrenarraystr "" } { indentionlvl "" } { endlvls "" } { callsource "" } { usebotlist 0 } } {
	if [isempty indentionlvl] { set indentionlvl -1 }
	set result ""
	# Initialize variables and children array from $childrenarraystr

	# How to check this against flat TCL?
	if {$root eq {}} {if [info exists ::botnet-nick] { set root ${::botnet-nick} } }

	# Let's avoid TCL8.5's -NOCASE for now (and check for flat TCL)
	if ![string eq "" [info commands bots]] {
		set bots [bots]
		set m [lsearch -glob [stl $bots] [stl $root]]
		if { $m != -1 } { set root [lindex $bots $m] }
	}

	if {$childrenarraystr eq {}} { set childrenarraystr [tree:getchildren] }
	if [isempty childrenarraystr] { if [isempty root] { return $::botnick } { return $root } }
	array set childrenarray $childrenarraystr
	set children $childrenarray($root)

	# Exclude direction we came from to avoid infinite recursion
	if { [set pos [lsearch -exact $children $callsource]] >= 0 } { set children [lreplace $children $pos $pos] }
	# First line of the whole thing (root node)
	if { $indentionlvl < 0 } { append result $root }

	# Indent and proceed with prefix-drawing ("| | | ..")
	incr indentionlvl
	set prefix "  "
	for {set i 0} {$i < $indentionlvl} {incr i} {
		if {[lsearch -exact $endlvls $i] >= 0} { append prefix " " } else { append prefix "|" }
		append prefix "    " ; # 4 spaces
	}

	# In case this is being run as flat TCL (without Eggdrop)....
	if ![string eq "" [info commands botlist]] { set botlist [botlist] } { empty botlist }
	for { set i 0 } { $i < [llength $children] } { incr i } {
		# Add a child to the list and recurse into its children
		set child [lindex $children $i]
		# not last child? "`--", else "|--"

		# If this is using the botnet, use BOTLIST to check sharing
		# (otherwise, ignore it)
		if $usebotlist {
			# If $BOTNET = "" (or NG) this will always fail.
			set m [lsearch -glob [stl $botlist] [stl [list $root $child * *]]]
			if { $m > -1 } { set shareflag [lindex [lindex $botlist $m] end] }
		} {
			empty shareflag
		}

		if { $i < [llength $children]-1 } {
			lappend result "${prefix}|${shareflag}-$child"
		} else {
			lappend result "${prefix}`${shareflag}-$child"
			lappend endlvls $indentionlvl
		}
		# Recursive call
		set result [concat $result [tree $child $childrenarraystr $indentionlvl $endlvls $root]]
	}
	# Each iteration of this proc returns a list of lines to be added in the collector/caller

	return $result
}

# Get an array: keys are bots and the values are lists of the direct children of that bot
proc tree:getchildren {} {
	array set result {}
	foreach node [bots] {
		set result($node) [list]
	}
	# now append children to their parent
	foreach info [botlist] {
		foreach {bot uplink} $info break
		lappend result($uplink) $bot
		lappend result($bot) $uplink
	}
	return [array get result]
}

proc tree:hops {} {
	foreach bot [bots] {
		set trace [tree:hops_scan trace $bot list]
		set old $trace
		set trace [lreplace $trace 0 0]; # Delete main hub
		set trace [lreplace $trace end end]; # Delete bot itself
		if [isempty trace] { set trace $me }
		set tracePath($bot) $trace
	}
	return [array get tracePath]
}

proc tree:path {bot1 bot2} {
	set bots [bots]

	array set c [list 0 "" 1 ""]

	# What if "me" is one of the bots?
	if [string eq -nocase ${::botnet-nick} $bot1] {return [tree:hops_scan trace $bot2 list]}
	if [string eq -nocase ${::botnet-nick} $bot2] {return [lreverse [tree:hops_scan trace $bot1 list]]}

	set t_1 [tree:hops_scan trace $bot1 list]
	set t_2 [tree:hops_scan trace $bot2 list]

	# Remove self if necessary
	if {![string eq $bot1 ${::botnet-nick}] && ![string eq $bot2 ${::botnet-nick}]} {
		set t_1 [lreplace $t_1 0 0]
		set t_2 [lreplace $t_2 0 0]
	}
	set t_1 [lreverse $t_1]
	set t_2 [lreverse $t_2]

	set final [list]
	foreach a $t_1 {
		set m [lsearch -exact $t_2 $a]
		if {$m < 0} {
			lappend final $a
		} {
			set final [concat $final [lreverse [lrange $t_2 0 $m]]]
			break
		}
	}
	return $final
}

proc tree:hops_scan { { traceme "" } { traceto "" } { listonly "" } } {
	upvar #0 botnet-nick bnn

	set botlist [botlist]
	set bots [bots]
	emptyarray hub hubs leaves
	empty header
	zero text_trace
	if [notempty traceto] {
		if [string eq -nocase TRACE $traceme] {
			one text_trace
			set header "Trace ($bnn -> %traceto%): "
			set traceme $traceto
		}
	}

	foreach link $botlist {
		set l [lindex $link 0]
		set h [lindex $link 1]

		if ![info exists hub($l)] {empty hub($l)}
		lappend hub($l) $h

		if ![info exists leaves($h)] {empty leaves($h)}
		if ![string eq -nocase $bnn $h] {lappend leaves($h) $l}
	}
	foreach leaf [array names leaves] {
		set data $leaves($leaf)
		set ll [llength $data]
		if $ll {set hubs($ll) $leaf}; # Remove empty reflexive
	}

	if [isempty traceme] {return [array get hubs]}

	if [string eq * $traceme] {set list_trace $bots} {set list_trace $traceme}

	empty result
	foreach traceme $list_trace {
		if [string eq -nocase $bnn $traceme] {set traceme $bnn} {set traceme [uniquematch $bots $traceme]}
		regsub -all -- %traceto% $header $traceme header_new
		if [string eq -nocase $traceme $bnn] {lappend result ${header_new}0; continue}

		if ![info exists hub($traceme)] {lappend result ${header_new}-1; continue}
		empty return stack
		zero loop
		set max [llength [bots]]
		set current $traceme
		set traceto $bnn

		while 1 {
#debug =LOOP $current bnn
			if [string eq $current $traceto] {
				lappend stack $traceme
				if $text_trace {set header_new "[join $stack " -> "]: "}
				break
			}
			set current $hub($current)
			lprepend stack $current
			incr loop
			if {$loop > $max} {return -1}
		}
		lappend result ${header_new}$loop
	}
	if [isempty stack] {set stack $bnn}; # Presume a bot trace on itself, list mode
	if $text_trace { if [notempty listonly] { return $stack } }
	return $result
}

