sb7 command add CONFIG 501 -chanspec CF CFG

sb7 register global [concat [data array value @CONFIG global] [data array value @CONFIG chan]]

proc @config { nick host handle chan arg } {
	set valid_global [list mute color burst pubcmd group rank shortcut debug binds chon backup access cservice bindver debuglevel format:time snuff]
	set valid_chan   [list mute color]
	set valid_abbr   [list shortcut sc binds bind pubcmd pc]

	sb7 setvars -global

	set base CONFIG:$chan
	set valid $valid_chan
	if [validflag -global] {
		if ![access check 501 $handle] { print -return -short -help $nick "Insufficient access for -GLOBAL flag use" }
		set base CONFIG
		set valid $valid_global
	}
#	lappend valid help list info hint
	set option $1l

	## 2014-08-24 14:00 -0700: Shall we just dispense with the abbreviation check, and let SWITCH handle that?
	## (And let DEFAULT deal with errors, leaving $VALID just to make listing options easier?)
	## (Yes, let's do that. DEFAULT switch option changed accordingly.)
	#foreach { a b } $valid_abbr { if { [lsearch -exact [string tolower $b] [string tolower $option]] != -1 } { set option $a } }
	#if { [lsearch -exact [string tolower $valid] $option] == -1 } { print -return -short -help $nick "Illegal CONFIG option: [string toupper $option]" }

	# File each option by type: this will commonize syntax checking
	array set types    [list]
	set types(integer) [list debuglevel]
	set types(boolean) [list mute rank bindver]
	set types(channel) [list home]
	set types(text)    [list group backup access cservice format:time snuff]
	set types(custom)  [list pubcmd shortcut burst color debug chon]
	# Custom: Debug(chan), color("",block), shortcut(local,global,owner), burst(allow,all)

	switch -exact -- $option {

		help {
			print -help $nick "\[CONFIG\]:"
			print -help $nick "Syntax: $::botnick CONFIG HELP"
			print -help $nick "Syntax: $::botnick CONFIG HINTS"
			print -help $nick "Syntax: $::botnick CONFIG <type> \[new value\]"
			print -help $nick "Syntax: $::botnick CONFIG INFO"
			print -help $nick "Syntax: $::botnick CONFIG LIST"
			if [access check 501 $handle] {
				print -help $nick "Syntax: $::botnick CONFIG -GLOBAL <type> \[new value\]"
				print -help $nick "Syntax: $::botnick CONFIG -GLOBAL INFO"
				print -help $nick "Syntax: $::botnick CONFIG -GLOBAL LIST"
			}
			print -help $nick ""
			print -help $nick "The CONFIG command sets various attribute settings for StormBot.TCL to function. By default, these settings affect the selected channel."
			print -help $nick "Available options: $valid_chan"
			if [access check 501 $handle] {
				print -help $nick "As a global administrator, you can set the global settings, as well, via the -GLOBAL flag."
				print -help $nick "Available options: $valid_global"
			}
			return 
		}

		hint {
			# New categories require addition to the list within DEFAULT
			print -short $nick "Hints for CONFIG settings:"
			switch -exact -- $2l {

				burst {
					print $nick "\[BURST\]:"
					print $nick "The \"burst\" mode is an output option that sends information to the server directly, bypassing Eggdrop's normal output queues. The queues exist to prevent the bot from flooding off the server for sending too much text in a short period of time."
					print $nick "This option is really only useful for a few situations: (1) bots serving as OPER (IRCop) bots, (2) bots that need to output a lot of text without reasonable delays (such as RSS feeds or long bible passages), or (3) bots that are used in illegal text flooding."
					print $nick "If you're in the last category, your actions will probably get your bot banned (K:lined / G:lined / Z:lined) from the server or network before too long."
					print $nick
					print $nick "(1) Set BURST/ALLOW mode on: $::botnick CONFIG -GLOBAL BURST ALLOW ON"
					print $nick "(2) Decide how you want burst mode used:"
					print $nick "[space 5](2 A) All users, all the time: $::botnick CONFIG -GLOBAL BURST ALL ON"
					print $nick "[space 5](2 B) Allow each user to select the option individually: $::botnick SET BURST ON"
					print $nick "[space 5](2 C) To use burst mode for just one command only (one-time mode), use the --BURST flag with the command (anywhere in the line is valid): $::botnick CONFIG HINT BURST --burst"
					print $nick "[space 5]Note: The admin CONFIG command needs to be used only once, not every time a user wants to set her / his burst mode value."
					print $nick
					print $nick "Any of the above options that are activated by \"ON\" can be turned off by \"OFF\" at any time."
					print $nick "If you want to use the burst mode effectively, your bot needs to be in a server class (by IP / host, or by connection port, defined by the Y:line) that supports a higher SENDQ value. Some IRCd (Internet Relay Chat daemons) servers allow server admins to set this value specifically. Otherwise, the server's internal queue may kick-in and the burst mode will only last for the first five (5) lines or so."
					return
				}

				home {
					print $nick "\[HOME\]:"
					print $nick "The \"home\" channel is the channel to which $::botnick will report all important actions. \"Important\" is defined as: LOGIN / OLOGIN, bans, security alerts, and maintenance issues."
					print $nick "The home channel alerts are very useful for bot-loaning groups and other organizations, however, they are almost useless for the private bot user. Therefore, I've allowed several options to control home channel output."
					print $nick "To turn on all alerts to the home channel, just select a channel and store it via: $::botnick CONFIG -GLOBAL HOME <valid channel>"
					print $nick "If this has not been set yet, alerts will go (by default) to the first channel listed in the bot's memory ( the first channel you put the bot on chronologically. In the case of ${::botnick}, it's: [lindex [channels] 0] )"
					print $nick "To silence all output to the home channel, use the MUTE option: $::botnick CONFIG -GLOBAL MUTE ON"
					print $nick "This will kill all home channel alerts to the channel. This will NOT block normal output to the channel, such as the SAY command or this output you are reading now."
					return
				}

				default { print -short -return $nick "I have helpful hints on the following subjects: home, burst. Use: $::botnick CONFIG $flags HINT <HOME | BURST>" }

			}
			?
		}

		list { print -return -short $nick "Valid data types: [ajl $valid]" }

		info {
			print -short $nick "Available configuration settings & values:"
			set max [get longest $valid]
			foreach a [lsort -uni -inc -dict [none [ldestroy -not -mult -glob -all -nocase $valid $2e] $valid]] {
				switch -exact -- [string tolower $a] {

					pubcmd { set data [data get $base $a] ; if [notempty data] { lassign $data pc_mode pc_char ; set data "mode ([boolean -offon $pc_mode]) -- chars($pc_char)" } }

					default { set data [data get $base $a] }

				}

				print $nick "[format %${max}s $a]: [none $data <none>]"
			}
			return 0
		}

		date - time - datetime - timestamp - timeformat - ts - tf - format - format:time - formattime {
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] FORMAT:TIME: [data get -normalize $base format:time]" }
			set value $2e
			data set $base format:time $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: FORMAT:TIME (${value})"
		}

		dl - debug - debuglevel {
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -normalize $base bind:version]" }
			if [string eq -nocase HELP $2] { print -return -help $nick "\[CONFIG -GLOBAL DEBUGLEVEL\] Debug level determines how much information will be shown when an error occurs. Options: \"0\" (no information), \"1\" (minimal information), & \"2\" (all debug information, only needed at the coder's request, usually)" }
			if { [lsearch -exact [list 0 1 2] $2] == -1 } { print -return -help $nick "\[CONFIG -GLOBAL DEBUGLEVEL\] Illegal value \"${2}\" (valid options: 0, 1, & 2)" }
			set value $2
			data set $base debuglevel $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		bindver - ver - version {
			# Might need to remove "VER" and even "VERSION" if a conflict exists with a future option
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -boolean $base bind:version]" }
			set value $2
			data set $base bind:version $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		cservice - cserv {
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -boolean $base cservice]" }
			set value $2
			data set $base cservice $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		access {
			print -help -return $nick "\[CONFIG -GLOBAL ACCESS\] This option is not available."
			# Options: "flag" "level"
			# This will allow the bot owner to set what kind of access checks / compares will be used:
			# Original SB3: global +v can only do local +v commands
			# SB4 / SB5 / SB6: universal access level system (a 501 (global +v) can do 500 commands on channels)
			# Other than a few specific places, this only needs to alter how ACCESS COMPARE works
			return
		}

		backup {
			print -help -return $nick "\[CONFIG -GLOBAL BACKUP\] This option is currently disabled."
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] BACKUP current setting: [data array get $base backup][iff [data array get -boolean config backup:keepall] " (keeping all files by time-stamping them)"]" }
			if [string eq -nocase HELP $2] {
				print -help $nick "\[CONFIG -GLOBAL BACKUP\]:"
				print -help $nick "Syntax: $::botnick CONFIG -GLOBAL BACKUP HELP"
				print -help $nick "Syntax: $::botnick CONFIG -GLOBAL BACKUP \[-KEEPALL\] <NEVER | ALWAYS | HOURLY | DAILY>"
				print -help $nick ""
				print -help $nick "This option makes $::botnick save a BACKUP of all files (user, channel, & data) automatically."
				print -help $nick "[space 5]NEVER: turn option off (don't do automatic backups\; use the BACKUP command manually / on demand)"
				print -help $nick "[space 5]ALWAYS: every time either of these files are saved, make a backup immediately"
				print -help $nick "[space 5]HOURLY: make backups every hour on-the-hour"
				print -help $nick "[space 5]DAILY: make backups every day at midnight (affected by \$::HOURLY-UPDATES)"
				print -help $nick "[space 5]-KEEPALL: when saving the backup file, -KEEPALL will save the backup with a timestamp as part of the file name. Otherwise, it will just save as \"(file name)~bak\" (over-writing it each time it's saved)"
				return
			}

			# We need to allow no text (flag only) so we can change just the flag
			flags:simple $2 -keepall option flags
			set um [uniquematch [list never always hourly daily] $option]
			if [isempty um] {
				set um [data array get $base backup] 
			} {
				data array set $base backup $um
			}
			set keepall [validflag -keepall]
			data array set $base backup:keepall $keepall
			saveme data
			print $nick "\[CONFIG -GLOBAL BACKUP\] Automatic backups will occur: ${um}[iff $keepall " (keeping all files by time-stamping them)"]"
			return
		}

		chon {
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data array get $base $1]" }
			if [string eq -nocase HELP $2] {
				print -return -help $nick "\[CONFIG -GLOBAL CHON\]:"
				print -return -help $nick "Syntax: $::botnick CONFIG -GLOBAL CHON HELP"
				print -return -help $nick "Syntax: $::botnick CONFIG -GLOBAL CHON +option or -option"
				print -return -help $nick "This option will allow you to control the \"announce to home channel who is connecting to DCC CHAT to the bot\" report."
				print -return -help $nick "Options:"
				print -return -help $nick "[space 5]OWNER: bot permanent owners ([ajl [get permowners]])"
				print -return -help $nick "[space 5]GLOBAL: all admins (levels 501 - 999)"
				print -return -help $nick "[space 5]CHANOWNER: all channel owners (level 500 on any channel)"
				print -return -help $nick "[space 5]ALL: all known users, regardless of access level (this will be the \"noisiest\" option)"
			}
			set data [data array get $base $1]
			empty new
			foreach item $2e {
				if ![regexp -- {^[\+\-]} $item] { print -help -return $nick "\[CONFIG -GLOBAL CHON\] Unknown option [join $item] (must be +/-option)" }
				switch -glob -- [string tolower $item] {
					?owner - ?owners { lappend new [left $item 1]botowner }
					?global - ?chanowner - ?all { lappend new $item }
					default { print -help -return $nick "\[CONFIG -GLOBAL CHON\] Unknown option [join $item]" }
				}
			}
			# LUNIQUE is needed here (within the loop) because duplicates can fowl-up the combinations during processing
			foreach a $new { debug data a ; set data [lunique [lcancel -replace -nocase $data $a]] }
			data set $base $1 [string tolower $data]
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${data})"
		}

		mute { # Option: boolean
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -boolean $base $1]" }
			set value [boolean -integer $2]
			data set $base $1 $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		home { # Option: channel
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -boolean $base $1]" }
			set value $2
			if ![validchan $value] { print -return -help $nick "\[CONFIG\] Illegal channel: $value" }
			data set $base home $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		group { # option: text
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] ${1u}: [data get -boolean $base $1]" }
			set value $2e
			data set $base group $value
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${value})"
		}

		pc - pubcmd {
			lassign [data get CONFIG PUBCMD] offon pubcmd
			if [string eq "" $2] { print -return -help $nick "\[CONFIG\] PUBCMD ([boolean -on $offon]): $pubcmd " }
			if [istrue $2] { set offon true } elseif [isfalse $2] { set offon false } else { set pubcmd $2 }
			data set $base pubcmd [list $offon $pubcmd]
			saveme data
			print -return $nick "\[CONFIG\] Updated setting: $1u (${offon}: $pubcmd)"
		}

		sc - shortcut {
			# Quick clean up of shortcut data ....
			foreach a [list all global owner] { data array set CONFIG SHORTCUT:$a [lsort -unique -increasing -dictionary [data array value CONFIG SHORTCUT:$a]] }
			array set bindflags [list all - global vlo owner n] ; # -- $BINDFLAGS(global) must match BSERVICE BOTS SHORTCUT AUDIT/$FLAGS_GLOBAL
			switch -exact -- [string tolower $2] {

				"" - list {
					print -header $nick "local: [none [lsort -uni -dict -inc [data get -lower $base shortcut:all]] <none>]"
					print -header $nick "global: [none [lsort -uni -dict -inc [data get -lower $base shortcut:global]] <none>]"
					print -header $nick "owner: [none [lsort -uni -dict -inc [data get -lower $base shortcut:owner]] <none>]"
					return 
				}

				add {
					if [string eq "" $3] { print -return -help -short $nick "What shortcut(s) am I adding?" }
					if ![info exists bindflags($3l)] { print -return -help -header $nick "Unknown level: $3u (valid options: all, global, & owner)" }
					foreach a $4e {
						data array lappend $base shortcut:$3 $a
						if [data array get -boolean $base bind:pub] { bind pub $bindflags($3l) [string tolower [join $a]] sb7:dispatch }
					}
					saveme data
					print -short $nick "Added binds: [ajl $4e]"
					return
				}

				del - delete {
					if [string eq "" $3] { print -return -help -short $nick "What shortcut(s) am I removing?" }
					array set bindflags [list all - global vlo owner n]
					set total ""
					foreach type [array names bindflags] {
						set binds [data get -lower $base shortcut:$type]
						foreach a $3e {
							set m [lsearch -exact [string tolower $binds] [string tolower $a]]
							if { $m != -1 } {
								lappend total $a
								set binds [lreplace $binds $m $m]
								if [data get -boolean $base bind:pub] { catch { unbind pub $bindflags($type) $a sb7:dispatch } }
								if [data get -boolean $base bind:not] { catch { unbind notc $bindflags($type) * sb7:dispatch:not } }
								foreach cmd [sb7 command list] {
									if [data get -boolean $base bind:msg] { catch { unbind msg $bindflags($type) $a sb7:dispatch:msg ; sb7:bind restore $cmd } }
									if [data get -boolean $base bind:dcc] { catch { unbind dcc $bindflags($type) $a sb7:dispatch:dcc ; sb7:bind restore $cmd } }
								}
							}
						}
						data array set $base shortcut:$type $binds
					}
					saveme data

					# Collect default binds
					zero killed
					foreach a $3e {
						foreach bind [binds [escape [join $a] ?*]] {
							lassign $bind type flags trigger count proc
							lappend total $trigger
							unbind $type $flags $trigger $proc
							incr killed
						}
					}

					print -short $nick "Removed binds: [none $total <none>]"
					if $killed { print -short $nick "Killed an [iff { $killed > 1 } "[comma $killed] "]additional default [plural bind $killed]." }
					return
				}

				clear {
					if ![string eq -nocase CLEAR $2] { print -return -help -short $nick "Are you [effects sure up u b]?! Use \"CLEAR CLEAR $3\" to convince me." }
					array set bindflags [list all - global vlo owner n]
					if ![info exists bindflags($3l)] { print -return -help -header $nick "Unknown level: $2u (valid options: all, global, &, owner)" }
					set binds [data get -lower $base shortcut:$3]
					foreach bind $binds {
						if [data get -boolean $base bind:pub] { unbind pub $bindflags($2l) $bind sb7:dispatch }
						if [data get -boolean $base bind:not] { unbind notc $bindflags($2l) * sb7:dispatch:not }
						foreach cmd [sb7 command list] {
							if [data get -boolean $base bind:msg] { unbind msg $bindflags($3l) $bind sb7:dispatch:msg ; sb7:bind restore $cmd }
							if [data get -boolean $base bind:dcc] { unbind dcc $bindflags($3l) $bind sb7:dispatch:dcc ; sb7:bind restore $cmd }
						}
					}
					data array set $base shortcut:$3 ""
					saveme data
					print -return -short $nick "Removed all $3u binds: $3e"
				}

				default { print -return -help -header $nick "Unknown option: $1u $2u" }

			}

		}

		bind - binds {
			set list [list default all global owner]
			set binds [get third [binds sb7:dispatch]]
			foreach a $list { array set type [list $a ""] }
			foreach bind $binds {
				set ok 0
				foreach a $list {
					set m [lsearch -exact [data array get -lower CONFIG SHORTCUT:$a] $bind]
					if { $m != -1 } { lappend type($a) $bind ; set ok 1 }
				}
				if !$ok { lappend type(default) $bind }
			}
			print -header $nick "Current binds:"
			print $nick "Owner: [none [ajl $type(owner)] <none>]"
			print $nick "Global: [none [ajl $type(global)] <none>]"
			print $nick "All: [none [ajl $type(all)] <none>]"
			print $nick "Default: [none [ajl $type(default)] <none>]"
			print $nick "To change these binds, use: $::botnick CONFIG -GLOBAL SHORTCUT"
			return
		}

		burst {
			switch -exact -- [string tolower $2] {

				"" { print -return $nick "\[CONFIG -GLOBAL BURST\] Current burst control mode: [none [data array get config burst] <none>]" }

				help {
					print $nick "\[CONFIG -GLOBAL BURST\] The BURST mode allows you to control the queue-bypass mode of the output parser. This will allow user output to be flushed directly to the IRCd (bypassing Eggdrop's output queues). This can be abused in many ways and can also get the bot flooded off the server."
					print $nick "The available options are: ALL (force all user output into burst mode, regardless of user preferences)"
					print $nick "The available options are: USERS (allows users to set their preference, via: [effects "$::botnick SET BURST < OFF | ON >" u])"
					print $nick "The available options are: OFF (all output goes through the queues as normal. The --BURST flag can override this on a line-by-line basis on the command-line)"
					print $nick "The available options are: BLOCK (blocks all burst mode options, including the command-line option: --BURST)"
					print $nick "Note: this does not affect the standard output to the \"home channel\" or output caused by commands like SAY."
					return
				}

				all {
					set mode force
					set tag "all users will experience burst mode (\"burstforce\" mode)"
				}

				user - users {
					set mode user
					set tag "users can set their own burst mode setting via: $::botnick SET BURSTMODE < OFF | ON > (\"burstallow\" mode)"
				}

				none - off {
					set mode off
					set tag "burst mode is turned off for all users (command-line flag --BURST is available)"
				}

				kill - block {
					set mode block
					set tag "burst mode is administratively off and unavailable to all users (command-line flag --BURST is also disabled)"
				}

				default { print -help -return $nick "\[CONFIG -GLOBAL BURST\] Unknown option: [join $2]" }

			}
			data array set config burst $mode
			saveme data
			print $nick "\[CONFIG -GLOBAL BURST\] Burst mode is now: $mode ($tag)"
			return
		}

		color {
			#
		}

		debug {
			#
		}

		rank {
			#
		}

		snuff {
			if ![validflag -global] { print -help -return $nick "\[GLOBAL -GLOBAL SNUFF\] This option is for global users only." }
			switch -exact -- [string tolower $2] {

				help {
					print -help $nick "\[CONIG -GLOBAL SNUFF\]:"
					print -help $nick "Syntax: $::botnick CONFIG -GLOBAL SNUFF ERROR (shows current status)"
					print -help $nick "Syntax: $::botnick CONFIG -GLOBAL SNUFF ERROR OFF"
					print -help $nick "Syntax: $::botnick CONFIG -GLOBAL SNUFF ERROR ON"
					# If any other options, like snuff:debug are added, include their HELPs here
					print -help $nick ""
					print -help $nick "The SNUFF ERROR command determines whether or not $::botnick will complain if a non-command word is used with any of the valid triggers (normal \[PUB\] or PUBCMD \[PUBM\]). Turning this on will allow the bot to \"quietly ignore\" any non-command words used with a matching trigger. This reduces \"channel noise\" (text output) from the bot. Options: OFF, ON"
					# If any other options, like snuff:debug are added, include their detailed HELPs here
					return
				}

				error {
					set value [normalize [data array get config snuff:error]]
					switch -exact -- [string tolower $3] {

						help { print -help -return $nick "The SNUFF ERROR command determines whether or not $::botnick will complain if a non-command word is used with any of the valid triggers (normal \[PUB\] or PUBCMD \[PUBM\]). Turning this on will allow the bot to \"quietly ignore\" any non-command words used with a matching trigger. This reduces \"channel noise\" (text output) from the bot. Options: OFF, ON" }

						"" { print -return $nick "\[CONFIG -GLOBAL SNUFF ERROR\] Current value: [boolean -offon $value]" }

						off - on {
							set new [boolean $3]
							data array set config snuff:error $new
							saveme data
							print -return $nick "\[CONFIG -GLOBAL SNUFF ERROR\] New value: [boolean -offon $new]"
						}

						default { print -help -return $nick "\[CONFIG -GLOBAL SNUFF\] Unknown option: $3" }

					}
				}

				default { print -help -return $nick "\[CONFIG -GLOBAL SNUFF\] Unknown option: $2" }

			}
		}

		default { print -help -return $nick "Unknown CONFIG option: $1" }

	}
	?
}

# Should we leave this here, or, should it have its own place (or even go to TAIL)?
proc config:check:chon { handle idx } {
	set chon [data array get config chon]

	# Check for perm owners (allow for hidden option!)
	if [access check 1000 $handle] {
		if [inlist -nocase $chon +botowner] {
			if ![boolean [userinfo get $handle nochon]] { print -home "\[CHON\] $handle (botowner) just connected to DCC" }
		}
		return
	}

	# Check for admins
	if [access check 501 $handle] {
		if [inlist -nocase $chon +global] { print -home -return "\[CHON\] $handle (admin) just connected to DCC" }
		return 
	}

	# Check for chan owners
	if [inlist -nocase $chon +chanowner] {
		empty chans
		foreach chan [channels] { if [access check 500 $handle $chan] { lappend chans $chan } }
		if [notempty chans] { print -home -return "\[CHON\] $handle (chanowner: [ajl $chans]) just connected to DCC" }
		#return
	}

	# All (default: just print it)
	if [inlist -nocase $chon +all] { print -home -return "\[CHON\] $handle just connected to DCC" }

	# Never mind .... (:
	return 0
}

proc config:check:backup { min hour day month year } {
	set backup [none [data array get config backup] never]
	if [string eq -nocase NEVER $backup] { return 0 }
	set ok 0
	if { [string eq -nocase HOURLY $backup] && [string eq 00 $min] } { set ok 1 }
	if { [string eq -nocase DAILY  $backup] && [string eq 0000 ${min}${hour}] } { set ok 1 }
	if $ok { saveme backup ; data backup }
	return 0
}

#####
# BootStrap:

bind chon - * config:check:chon
bind time - "00 *" config:check:backup


