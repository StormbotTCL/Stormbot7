sb7 command add ACCESS     0 -core ; # -chanspec <--- due to -GLOBAL, don't use -CHANSPEC
sb7 command add ADDUSER  400 -none -redirect AU
sb7 command add ADDBOT   400 -none -redirect AB
sb7 command add MODUSER  400 -none -redirect MU
sb7 command add REMUSER  400 -none -redirect RU
sb7 command add USERLIST   1 -none -redirect UL
sb7 command add ADMIN    501 -none -redirect ADM

proc @adduser  { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS ADD <level> <list of users>" }
proc @addbot   { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS ADD -BOT <bot> \[address\]" }
proc @remuser  { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS DEL <list of users>" }
proc @moduser  { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS MOD <new level> <list of users>" }
proc @admin    { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS ADD -GLOBAL <level> <list of users>" }
proc @userlist { nick host handle chan arg } { print -help -short -return $nick "Syntax change: ACCESS LIST \[-GLOBAL\] \[-SHORT\] \[-DEAD\] \[range\]" }

proc @access { nick host handle chan arg } {
	# This will be the all-encompassing ACCESS controller

	sb7 setvars -global -bot -short; # Other flags will be checked by each sub-routine
	if [isempty 1] { print -help -return -short $nick "Missing option" }

	set global [validflag -global]
	if $global { if ![access check 501 $handle] { print -error -return -short $nick "You don't have access to the -GLOBAL flag." } }

	switch -exact -- $1l {

		help {
			print -help $nick "\[ACCESS\]:"
			print -help $nick "Syntax: $::botnick ACCESS HELP"
			print -help $nick "Syntax: $::botnick ACCESS ADD <level> <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS ADD -GLOBAL <admin level> <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS ADD -BOT <botnick> <address> <bot port>"
			print -help $nick "Syntax: $::botnick ACCESS MOD -GLOBAL <level> <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS MOD -GLOBAL <admin level> <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS DEL <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS DEL -GLOBAL <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS SCRUB <list of nicks>"
			print -help $nick "Syntax: $::botnick ACCESS LIST \[-GLOBAL\] \[-SHORT\] \[-DEAD\] \[range of levels\]"
			print -help $nick "Syntax: $::botnick ACCESS AUDIT"
			print -help $nick "Syntax: $::botnick ACCESS <user>"
			print -help $nick ""
			print -help $nick "The ACCESS command is a combination of several previously separate commands: ADDUSER, ADDBOT, MODUSER, REMUSER, ACCESS, USERLIST, & ADMIN. For simplicity, due to similaries in code, I'm combining them together into one bead."
			print -help $nick "For you to be able to use my commands, you need to be given \"access\" to my command list. The ACCESS command grants you access, based on the \"level of responsibility\" a channel owner (or global admin) wants you to have."
			print -help $nick "As in SB4, SB5, & SB6, I will honor the two formats to express access levels: word names (chanop, globmaster), or, numeric levels (100, 800)."
			print -help $nick "You may use which format is easier for you. The numeric levels exist in order to create a hierarchy of users within each level (a 250 chanop \"out-ranks\" a 200 chanop, similar to a \"senior op\" position)."
			print -help $nick "You can add / modify users BELOW your level\; you can not add / move someone to your same (or above) level."
			print -help $nick "To add someone as a global admin, you must ALSO be a global admin (level 800), and, like the local (channel) levels, you can only add someone up to your level \"minus one\" (you can't add someone to your exact level, or above)."
			print -help $nick "You can =NOT= add users at levels 1000 / 1001 through this command\; those levels are assigned based on the \$OWNER variable in my configuration file. If you only list one person, that person will have 1000 access\; if you list more than one person, the [effects "first one in order" bold underline] will be level 1001 and the others will all be level 1000."
			print -help $nick
			print -help $nick "The DEL command has two functions: used locally (for a channel), it only removes the user's access on that channel. If -GLOBAL is used, the entire user record is deleted\; it does not just remove global access only. To only remove global access, MOD to level 0."
			print -help $nick "The SCRUB option will remove all access levels on all channels, but, leave the global access level untouched (the opposite of a MOD -GLOBAL 0 which removes global access but leaves channel-level accesses untouched)."
			print -help $nick "For legacy reasons, I'm BINDing the original commands to provide help and hints toward the new syntax."
			return
		}

		hint - hints {
			print -help $nick "\[ACCESS\]:"
			print -help $nick "The following commands are either (1) altered, or, (2) absorbed into ACCESS:"
			print -help $nick "ADDUSER -> $::botnick ACCESS ADD <level> <list of users>"
			print -help $nick "MODUSER -> $::botnick ACCESS MOD <level> <list of users>"
			print -help $nick "REMUSER -> $::botnick ACCESS DEL <list of users>"
			print -help $nick "REMUSER -GLOBAL -> $::botnick ACCESS DEL -global <list of users>"
			print -help $nick "USERLIST -> $::botnick ACCESS LIST \[level / range\]"
			print -help $nick ""
			print -help $nick "When specifying a user (or list of users), ACCESS will accept:"
			print -help $nick "[space 5](1) nick of a user on the channel"
			print -help $nick "[space 5](2) handle of any user (will do nick look-up)"
			print -help $nick "[space 5](3) hard handle (\"\$${handle}\" which will bypass nick look-up)"
			print -help $nick "[space 5](4) any declared ALIAS (which users can set via the SET ALIAS command)"
			print -help $nick "[space 5](5) hard tokens (like \"\$BOTOWNER\" or \"\$GLOBALOPS\" or \"\$CHANMASTERS\")"
			print -help $nick ""
			print -help $nick "When specifying a level, the ACCESS command will accept:"
			print -help $nick "[space 5](1) specific levels (like \"100\" or \"=500\")"
			print -help $nick "[space 5](2) a range of levels (like \"200-500\" or \"<=200\")"
			return
		}

		add - adduser {
			# SB3/SB4/SB5/SB6:ADDUSER
			flags:simple [lrange $arg 2 end] [list -global -bot] text flags
			set users [lassign $text level]
			if [validflag -bot] { set level 1 }
			if [validflag -global] { 
				if ![access check 700 $handle] { print -short -return $nick "You don't have access to use the -GLOBAL flag." } 
				set target global
				set lower 501
				set limit 999
				if ![access check $limit $handle] { set limit [expr [access get $handle] - 1] }
			} {
				if ![access check 400 $handle] { print -short -return $nick "You don't have access to add users. Ask a channel master to add users to this channel." } 
				set target $chan
				set lower 1
				set limit 500
				if ![access check $limit $handle $chan] { set limit [expr [access get $handle $chan] - 1] }
			}
			if { $level < $lower } { print -short -return $nick "You can only add users to level $lower or above." }
			if { $level > $limit } { print -short -return $nick "You can only add users to level $limit or below." }
			array set status [list ok "" access "" moduser "" onchan "" self ""]
			if [validflag -bot] { lassign $text users address port }
			foreach user $users {
				set user [join $user]
				lassign:array adduser [whois $user $handle] online nick host handle chan
#				if [string eq -nocase $handle $adduser(handle)] { lappend status(self) $user ; continue }
				if ![access compare $handle $adduser(handle)] { lappend status(access) $user ; continue }
				if [none [access get $adduser(handle) $chan] 0] { lappend status(moduser) $user ; continue }
				if [validuser $adduser(handle)] {
					lappend status(ok) [nph $adduser(nick) $adduser(handle)]
				} {
					# We need to add a new person
					# At this point, s/he must be on channel to capture a host
					if ![onchan $user $chan] { lappend status(notonchan) $user ; continue }
					if [validflag -bot] {
						addbot $user $address
						setuser $user hosts ${user}![getchanhost $user $chan]
					} {
						adduser $user [maskhost [getchanhost $user $chan]]
					}
					set adduser(nick) $user
					set adduser(handle) $user
					lappend status(ok) $user
				}
				userinfo set $adduser(handle) access:$target $level
				# Determine flags
				foreach entry [data get userlevels] {
					lassign $entry name low range flagset group
					if [inrange $range $level] {
						set f [split $flagset |]
						if [validflag -global] {
							chattr $adduser(handle) -abcdefghijklmnopqrstuvwxyzNM
							chattr $adduser(handle) +[lindex $f 0]
						} {
							chattr $adduser(handle) |-abcdefghijklmnopqrstuvwxyzNM $chan
							chattr $adduser(handle) |+[lindex $f 1] $chan
						}
						break
					}
				}
			}
			if [notempty status(self)] { saveme user ; print -short $nick "Unable to handle mirrors (can't add yourself!): [ajl $status(self)]" }
			if [notempty status(ok)] { saveme user ; print -short $nick "Added users: [ajl $status(ok)]" }
			if [notempty status(moduser)] { saveme user ; print -short $nick "Failed (have access\; use ACCESS MOD): [ajl $status(moduser)]" }
			if [notempty status(access)] { saveme user ; print -short $nick "Failed (insufficient access): [ajl $status(access)]" }
			if [notempty status(onchan)] { saveme user ; print -short $nick "Failed (unknown user, not in channel): [ajl $status(onchan)]" }
			return
		}

		ed - edit - mod - moduser {
			# SB3/SB4/SB5/SB6:MODUSER
			flags:simple [lrange $arg 2 end] [list -global] text flags
			set users [lassign $text level]
			if ![isnum -integer $level] { print -short -return $nick "Syntax: ACCESS MODUSER <integer level> <list of users>" }
			if [validflag -global] { 
				if ![access check 700 $handle] { print -short -return $nick "You don't have access to use the -GLOBAL flag." } 
				set target global
				set lower 501
				set limit 999
				if ![access check $limit $handle] { set limit [expr [access get $handle] - 1] }
			} {
				if ![access check 400 $handle] { print -short -return $nick "You don't have access to add users. Ask a channel master to add users to this channel." } 
				set target $chan
				set lower 1
				set limit 500
				if ![access check $limit $handle $chan] { set limit [expr [access get $handle $chan] - 1] }
			}

			if { $level < $lower } { print -short -return $nick "You can only modify users to level $lower or above." }
			if { $level > $limit } { print -short -return $nick "You can only modify users to level $limit or below." }
			array set status [list ok "" access "" unknown "" adduser "" self ""]
			foreach user $users {
				lassign:array moduser [whois [join $user] $handle] online nick host handle chan
#				if [string eq -nocase $handle $moduser(handle)] { lappend status(self) $user ; continue }
				if ![validuser $moduser(handle)] { lappend status(unknown) $user ; continue }
				if ![none [access get $moduser(handle) $chan] 0] { lappend status(adduser) $user ; continue }
				if ![access compare $handle $moduser(handle)] { lappend status(access) $user ; continue }
				userinfo set $moduser(handle) access:$target $level
				# Determine flags
				foreach entry [data get userlevels] {
					lassign $entry name low range flagset group
					if [inrange $range $level] {
						set f [split $flagset |]
						if [validflag -global] {
							chattr $moduser(handle) -abcdefghijklmnopqrstuvwxyzNM
							chattr $moduser(handle) +[lindex $f 0]
						} {
							chattr $moduser(handle) |-abcdefghijklmnopqrstuvwxyzNM $chan
							chattr $moduser(handle) |+[lindex $f 1] $chan
						}
						break
					}
				}
				lappend status(ok) $user
			}
			if [notempty status(self)] { saveme user ; print -short $nick "Unable to handle mirrors (can't modify yourself!): [ajl $status(self)]" }
			if [notempty status(ok)] { saveme user ; print -short $nick "Modified users (level $level): [ajl $status(ok)]" }
			if [notempty status(unknown)] { saveme user ; print -short $nick "Failed (unknown user): [ajl $status(unknown)]" }
			if [notempty status(adduser)] { saveme user ; print -short $nick "Failed (no access\; use ACCESS ADD): [ajl $status(adduser)]" }
			if [notempty status(access)] { saveme user ; print -short $nick "Failed (insufficient access): [ajl $status(access)]" }
			return
		}

		del {
			# SB3/SB4/SB5/SB6:REMUSER
			empty ok bad access none
			set me [access get $handle]
			if [validflag -global] {
				if { $me < 800 } { print -help -short -return $nick "You don't have access to do that globally (=800 access needed)" }
				foreach user $2e {
					lassign:array whois [whois $user $user $chan] online nick host handle chan authed
					if ![validuser $whois(handle)] { lappend bad $user ; continue }
					if [isempty authed] { set who $whois(handle) } { set who $whois(authed) }
					set level [access get $who]
					if { $level < 1 } { lappend none [nph $user $who] ; continue }
					if ![access compare $handle $who] { lappend access [nph $user $who] ; continue }
					deluser $who
					lappend ok [nph $user $who]
				}
				if [notempty ok] { saveme user ; print -short $nick "Successful REMUSER: [ajl $ok]" }
				if [notempty bad] { print -short $nick "Unsuccessful REMUSER (no such user): [ajl $bad]" }
				if [notempty none] { print -short $nick "Unsuccessful REMUSER (never had access): [ajl $none]" }
				if [notempty access] { print -short $nick "Unsuccessful REMUSER (insufficient access): [ajl $access]" }
				return
			}

			if { $me < 400 } { print -help -short -return $nick "You don't have access to do that on $chan (=400 access needed)" }
			foreach user $2e {
				lassign:array whois [whois $user $user $chan] online nick host handle chan authed
				if [isempty authed] { set who $whois(handle) } { set who $whois(authed) }
				if ![validuser $who] { lappend bad $user ; continue }
				set level [access get $who $chan]
				if { $level < 1 } { lappend none [nph $user $who] ; continue }
				if { $level >= $me } { lappend access [nph $user $who] ; continue }
				access set $who 0 $chan
				lappend ok [nph $user $who]
			}
			if [notempty ok] { saveme user ; print -short $nick "Successful REMUSER: [ajl $ok]" }
			if [notempty bad] { print -short $nick "Unsuccessful REMUSER (no such user): [ajl $bad]" }
			if [notempty none] { print -short $nick "Unsuccessful REMUSER (never had access): [ajl $none]" }
			if [notempty access] { print -short $nick "Unsuccessful REMUSER (insufficient access): [ajl $access]" }
			return
		}

		scrub {
			# Remove all chan accesses ; leave global undisturbed
			if [isempty 2] { print -help -return -short $nick "What users am I scrubbing?" }
			empty ok bad access ; # When comparing, use global levels
			set me [access get $handle]
			foreach user $2e {
				lassign [whois $user $user $chan] online wn wm wh wc
				switch -exact -- $online {
					-1 { lappend bad $user ; continue }
					 0 - 1 { set user $wh }
					 default { error "\[ACCESS SCRUB\] Unknown WHOIS reply: ONLINE($online):WN($wn):WM($wm):WH($wh):WC($wc) (report this to the coder)" }
				}
				if ![validuser $wh] { lappend bad $user ; continue }
				set list [ldestroy -all -not -nocase -glob -multiple [get first [userinfo list $user]] [list ACCESS:#*]]
				foreach element $list { userinfo set $user $element }
				if [string eq -nocase $user $wh] { lappend ok $user } { lappend ok "$user ([nph $wn $wh])" }
			}
			if [notempty ok] { saveme user ; print -short $nick "Successful SCRUBs: [ajl $ok]" }
			if [notempty bad] { print -short $nick "Failed SCRUBs: [ajl $bad]" }
			return
		}

		list {
			# SB3/SB4/SB5/SB6:USERLIST
			set arg [lreplace $arg 1 1]
			FLAGS -short -dead -global
			# Handle special case first: -NONE
			if [validflag -dead] {
				empty o
				foreach user [userlist -b] {
					zero m
					foreach channel [channels] { if [none [access get $user $channel] 0] { one m } }
					if [none [access get $user] 0] { one m }
					if !$m { lappend o $user }
				}
				if [isempty o] { print -short -return $nick "There are no dead (useless) users in the USERLIST. (:" }
				print -short $nick "The following users have no useful records: [ajl $o]"
				return
			}

			set global [validflag -global]
			if [validflag -short] {
				array set levels [list]
				foreach user [userlist -b] {
					if $global { set level [access get $user] } { set level [access get $user $chan] }
					lappend levels([none $level 0]) $user
				}
				foreach a [lsort -real -decreasing -unique [array names levels]] { print $nick "${a}: [ajl $levels($a)]" }
				return
			}
			array set users [list]
			foreach user [userlist -b] {
				if $global { set level [access get $user] } { set level [access get $user $chan] }
				lappend users($user) [none $level 0]
			}
			foreach a [lsort -dictionary -increasing -unique [array names users]] { print $nick "${a}: [ajl $users($a)]" }
			return
		}

		audit {
			flags:simple $2e [list -global -all] text flags true
			if $global { if ![access check 501 $handle] { print -error -return -short $nick "You don't have access to the -GLOBAL flag." } }
			if $all { if ![access check 501 $handle] { print -error -return -short $nick "You don't have access to the -ALL flag." } }
			set channels $chan
			if [validflag -all] { set channels [channels] }
			foreach channel $channels {
				array set audit [list flags1level0 "" level1flags0 "" nohosts ""]
				foreach user [userlist] {
					if [string eq "" [getuser $user hosts]] { lappend audit(nohosts) $user }
					if [matchattr $user b] {
						if { [access get $user $channel] > 0 } { lappend audit(botlevel) $user }
					} {
						if { [string match *|- [chattr $user $channel]] && ( [access get $user $channel] > 0 ) } { lappend audit(flags1level0) $user }
						if { ![string match *|- [chattr $user $channel]] && ( [access get $user $channel] == 0 ) } { lappend audit(flags1level0) $user }
					}
				}
				zero found
				if [notempty audit(nohosts)] { one found ; print $nick "\[ACCESS AUDIT: ${channel}\] Users with no hosts: [ajl $audit(nohosts)]" }
				if [notempty audit(flags1level0)] { one found ; print $nick "\[ACCESS AUDIT: ${channel}\] Users with flags but have not been ACCESS ADDed yet: [ajl $audit(flags1level0)]" }
				if [notempty audit(level1flags0)] { one found ; print $nick "\[ACCESS AUDIT: ${channel}\] Users with access (ACCESS ADD) but no flags: [ajl $audit(level1flags0)]" }
				if [notempty audit(botlevel)] { one found ; print $nick "\[ACCESS AUDIT: ${channel}\] Bots with channel access: [ajl $audit(botlevel)]" }
				if !$found { print $nick "\[ACCESS AUDIT: ${channel}\] No problems found! :)" }
				unset audit
			}
			return
		}

		default {
			# SB3/SB4/SB5/SB6:ACCESS
			lassign [whois $1 $1 $chan] online wn wm wh wc
			if [validuser $wh] { print -return -short $nick "[nph $wn $wh]: global [access get $wh] / ${chan} [access get $wh $chan]" ; # "[...] is currently: ${wn}!$wm on $wc" } { print -return -short $nick "${wn}: unknown user" } 
		}

	}
	return
}

proc sb7:dcc:-user {handle idx arg} {
	if [sb7 command iscmd PROTECT] {
		if [validuser $arg] {
			if [nozero [getdata $arg PROTECT]] {
				if ![access check [sb7 command get protect level] $handle] {
					putidx $idx "You can't use the core EGGDROP command \"-user\" to delete this user: PROTECTion is currently on."
					return 1
				}
			}
		}
	}
	*dcc:-user $handle $idx $arg
	return 1
}

proc sb7:dcc:-bot { handle idx arg } {
	if [sb7 command iscmd PROTECT] {
		if [validuser $arg] {
			if [nozero [getdata $arg PROTECT]] {
				if ![chkaccess [SB:commandlist level protect] $handle] {
					putidx $idx "You can't use the core EGGDROP command \"-bot\" to delete this user: PROTECTion is currently on."
					return 1
				}
			}
		}
	}
	*dcc:-bot $handle $idx $arg
	return 1
}

proc @access:fixlevels args {
	# 2014-11-04 07:52:00 -0800
	# Two streams were created: USERINFO/ACCESS:* (SB7) and USERINFO/USERINFO:* (SB6, back*-compat*).
	# Intention was to move to USERINFO/ACCESS:* but it wasn't handled everywhere in code, so the back*-compat* was broken.
	set changed 0
	foreach user [userlist] { foreach chan [concat global [channels]] { if ![string eq "" [userinfo get $user USERLEVEL:$chan]] { set changed 1 ; userinfo set $user ACCESS:$chan [userinfo get $user USERLEVEL:$chan] ; userinfo set $user USERLEVEL:$chan ; sb7 log "\[@ACCESS:FIXLEVELS\] Fixed user access data (USERLEVEL -> ACCESS): $user ($chan)" } } }
	if $changed { saveme user }
	return
}

#####
# Bootstrap:

catch { unbind dcc m|-  -user *dcc:-user }
catch {   bind dcc m|- /-user sb7:dcc:-user }
catch { unbind dcc t|-  -bot  *dcc:-bot  }
catch {   bind dcc t|- /-bot  sb7:dcc:-bot  }
@access:fixlevels

